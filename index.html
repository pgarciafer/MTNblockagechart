<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blockage Chart</title>

<link rel="icon" href="https://pgarciafer.github.io/shared-design-system/icons/Favicon-MTN.png" type="image/png">

<link rel="stylesheet" href="https://pgarciafer.github.io/shared-design-system/css/style.css">

<style>
/* NOTE: The :root variables (colors) are now handled by style.css.
   We only keep app-specific styles here.
*/

*, *::before, *::after {
  box-sizing: border-box;
}

body {
  /* Using variables from style.css */
  font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: var(--bg-color); 
  color: var(--text-color);
  margin: 0;
  padding: 24px;
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

.card {
  max-width: 1400px;
  margin: auto;
  padding: 24px;
  background: var(--container-bg);
  border-radius: 8px;
  box-shadow: var(--card-shadow);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

/* --- SECTION STYLES --- */
.card-section {
    background: #fafcff;
    border: 1px solid #e9eef5;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 24px;
}

.section-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--mtn-blue); /* From Shared CSS */
    margin-top: 0;
    margin-bottom: 16px;
    text-align: left;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

/* --- FORM ELEMENTS --- */
label {
  display: block;
  margin-top: 16px;
  margin-bottom: 8px;
  font-weight: 600;
  color: var(--mtn-blue);
  font-size: 14px;
  text-align: left;
}

input, select {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  font-size: 15px;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  background-color: #fff;
  color: var(--text-color);
  width: 100%;
}

input:focus, select:focus {
  outline: none;
  border-color: var(--mtn-sky);
  box-shadow: 0 0 0 3px rgba(88, 160, 212, 0.3);
}

/* Grid layout for top inputs */
.header-inputs {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
}

/* --- BUTTONS --- */
button {
  padding: 10px 20px;
  border: 1px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  font-size: 15px;
  font-weight: 600;
  transition: all 0.2s ease;
  position: relative;
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
  opacity: 0.7;
}

button:active:not(:disabled) {
  transform: scale(0.98);
}

#addBlockBtn, #generatePdf {
    background-color: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(27, 80, 135, 0.2);
}
#addBlockBtn:hover:not(:disabled), #generatePdf:hover:not(:disabled) {
  background-color: var(--primary-hover);
}

#removeAllImagesBtn {
    background-color: white;
    color: var(--danger-color);
    border: 1px solid var(--danger-color);
}
#removeAllImagesBtn:hover:not(:disabled) {
    background-color: var(--danger-color);
    color: white;
}

.button-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-top: 20px;
}

/* --- DRAG & DROP & GRID --- */
#drop-area {
  border: 2px dashed var(--mtn-sky);
  background: #D4E5F7; /* Pale Blue */
  background-opacity: 0.1;
  padding: 30px;
  text-align: center;
  cursor: pointer;
  border-radius: 12px;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 120px;
  margin-bottom: 20px;  
}

#drop-area:hover, #drop-area.highlight {
  border-color: var(--mtn-blue);
  background: #e6f0fa;
}
#drop-area p {
  font-size: 16px;
  font-weight: 500;
  color: var(--mtn-blue);
  margin: 0;
}

#grid {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    background: white;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
}

.cell {
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    display:flex;
    justify-content:center;
    align-items:center;
    overflow:hidden;
    position:relative;
    border-radius:6px;
    cursor:pointer;
    font-size: 2.5rem;
    font-weight: bold;
    color: #ccc;
    transition: border-color 0.2s;
}
.cell:hover:not(.center-cell) {
    border-color: var(--mtn-sky);
}
.cell img {
    width:100%;
    height:100%;
    object-fit:cover;
}
.cell:has(img) {
    font-size: 0;
    border: 1px solid #aaa;
}

.center-cell {
    background:white;
    cursor: default;
    border: none;
}
.center-cell .cell-number { display: none; }

/* --- TABLES --- */
table { width:100%; border-collapse:collapse; margin-top:12px; }
th, td { padding:10px 8px; text-align:center; border-bottom:1px solid var(--border-color); }
th { 
    color: var(--mtn-blue); 
    font-size: 13px; 
    font-weight: 700; 
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: left;
}
#zonesTable th:first-child, #zonesTable th:last-child { text-align: center; } 

#zonesTable td button{
  background: var(--danger-color);
  color:white;
  border-radius:4px;
  border:none;
  padding:6px 10px;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
}
#zonesTable td button:hover { background: var(--danger-hover); }

.zone-color-swatch {
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  border: 1px solid rgba(0,0,0,0.1);
  vertical-align: middle;
}

/* --- VESSEL OVERLAY --- */
#vesselImage {
    position: relative;
    width: 100%;
    height: 100%;
    background-image: url('https://pgarciafer.github.io/satcalc/IMG_0585.PNG');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    filter: drop-shadow(0 4px 12px rgba(0,0,0,0.15));
}
#overlayCanvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }

/* --- LAYOUT UTILS --- */
.app-layout { display: flex; flex-wrap: wrap; gap: 24px; }
.main-content { flex: 3; min-width: 400px; }
.preview-container { flex: 2; min-width: 300px; position: sticky; top: 24px; align-self: flex-start; }

#pdf-preview-content {
  border: 1px solid var(--border-color);
  background: #ffffff;
  padding: 15px;
  border-radius: 8px;
  box-shadow: var(--card-shadow);
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 80vh;
}
#pdf-preview-content img { width: 100%; display: block; border: 1px solid #eee; }

@media screen and (max-width: 900px) {
    .app-layout { flex-direction: column; }
    .preview-container { position: static; }
    .main-content, .preview-container { min-width: 0; }
}

@media screen and (max-width: 600px) {
    body { padding: 10px; }
    .card { padding: 16px; }
    .header-inputs { grid-template-columns: 1fr; }
    .button-container { grid-template-columns: 1fr; }
}

.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

#blockagePanel:not(.has-zones) > label,
#blockagePanel:not(.has-zones) #zonesTable thead {
    display: none;
}

/* --- MIC BUTTON --- */
.input-with-mic { position: relative; width: 100%; }
.input-with-mic input { padding-right: 40px; }
.mic-btn {
    position: absolute;
    right: 1px;
    top: 50%;
    transform: translateY(-50%);
    height: calc(100% - 2px);
    width: 38px;
    background: transparent;
    border: none;
    border-left: 1px solid var(--border-color);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    margin: 0;
    color: var(--text-muted);
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    /* Ensure the emoji looks centered */
    line-height: 1; 
}
.mic-btn:hover:not(:disabled) { 
    background-color: #f0f6ff;
    /* Optional: make it grayscale until hovered if you want a cleaner look */
    /* filter: grayscale(0%); */ 
}
.mic-btn.listening { 
    animation: pulseMic 1.5s ease-in-out infinite; 
}
@keyframes pulseMic {
    0% { box-shadow: inset 0 0 0 0 rgba(220, 53, 69, 0.4); }
    70% { box-shadow: inset 0 0 10px 0 rgba(220, 53, 69, 0.1); }
    100% { box-shadow: inset 0 0 0 0 rgba(220, 53, 69, 0); }
}
</style>
</head>
<body>
<div class="card">
  
  <header class="shared-header">
    <a href="https://www.mtnsat.com" target="_blank">
      <img src="https://pgarciafer.github.io/shared-design-system/icons/logo.png" alt="MTN Logo">
    </a>
    <h1>Blockage Chart</h1>
  </header>

  <div class="app-layout">
    <main class="main-content">
      
      <section class="card-section" id="vessel-info-section">
        <h2 class="section-title">Vessel Information</h2>
        <div class="header-inputs">
          <div class="input-with-mic">
            <input id="vesselName" type="text" placeholder="3LC_VesselName">
            <button class="mic-btn" data-target="vesselName" type="button" aria-label="Use voice input">ðŸŽ¤</button>
          </div>
          <div class="input-with-mic">
            <input id="antennaLocation" type="text" placeholder="Antenna & Location">
            <button class="mic-btn" data-target="antennaLocation" type="button" aria-label="Use voice input">ðŸŽ¤</button>
          </div>
          <input id="dateInput" type="date">
          <div class="input-with-mic">
            <input id="submittedBy" type="text" placeholder="Tech Name">
            <button class="mic-btn" data-target="submittedBy" type="button" aria-label="Use voice input">ðŸŽ¤</button>
          </div>
        </div>
      </section>

      <section class="card-section" id="blockage-zones-section">
        <h2 class="section-title">Blockage Zones</h2>
        <div class="panel" id="blockagePanel">
          <label>Blockage Zones (AZ Start / AZ Stop in degrees)</label>
          <table id="zonesTable">
            <thead><tr><th></th><th>AZ Start</th><th>AZ Stop</th><th>EL</th><th></th></tr></thead>
            <tbody id="zonesBody"></tbody>
          </table>
          <button id="addBlockBtn" style="width: 100%; margin-top: 12px;">Add Blockage Zone</button>
        </div>
      </section>

      <section class="card-section" id="photos-section">
        <h2 class="section-title">Supporting Photos</h2>
        <label for="fileElem" id="drop-area">
          <p>ðŸ“‚ Drop up to 8 photos here or click to browse</p>
        </label>
        <input type="file" id="fileElem" accept="image/*" multiple class="visually-hidden">
        <div id="grid">
          <div class="cell" id="cell-1" data-index="1">8</div>
          <div class="cell" id="cell-2" data-index="2">1</div>
          <div class="cell" id="cell-3" data-index="3">2</div>
          <div class="cell" id="cell-4" data-index="4">7</div>
          <div class="cell center-cell" id="cell-5" data-index="5">
            <div id="vesselImage">
              <canvas id="overlayCanvas"></canvas>
            </div>
          </div>
          <div class="cell" id="cell-6" data-index="6">3</div>
          <div class="cell" id="cell-7" data-index="7">6</div>
          <div class="cell" id="cell-8" data-index="8">5</div>
          <div class="cell" id="cell-9" data-index="9">4</div>
        </div>
      </section>

      <section class="card-section" id="actions-section">
        <h2 class="section-title">Actions</h2>
        <div class="button-container">
            <button id="generatePdf">Generate PDF</button>
            <button id="removeAllImagesBtn">Remove All Images</button>
        </div>
      </section>

    </main>
    
    <aside class="preview-container">
      <h2 class="section-title">Live PDF Preview</h2>
      <div id="pdf-preview-content">
        </div>
    </aside>
  </div> <input type="file" id="singleFileElem" accept="image/*" class="visually-hidden">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// Set default date to today
const today = new Date();
const yyyy = today.getFullYear();
const mm = String(today.getMonth()+1).padStart(2,'0');
const dd = String(today.getDate()).padStart(2,'0');
document.getElementById('dateInput').value = `${yyyy}-${mm}-${dd}`;

// --------- Blockage Zones -----------
const ZONE_COLORS = ['#E53935','#1E88E5','#43A047','#FB8C00','#8E24AA','#D81B60','#00ACC1','#FDD835'];
const zonesBody=document.getElementById('zonesBody');
const overlayCanvas=document.getElementById('overlayCanvas');
const overlayCtx=overlayCanvas.getContext('2d');
const vesselImg=document.getElementById('vesselImage');

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function validateZoneRow(tr) {
    const startInput = tr.cells[1].querySelector('input');
    const stopInput = tr.cells[2].querySelector('input');
    const start = parseFloat(startInput.value);
    const stop = parseFloat(stopInput.value);

    if (isNaN(start) || isNaN(stop)) {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
        return;
    }

    let angle = stop - start;
    if (angle < 0) {
        angle += 360; // Assumes wrap-around
    }

    if (angle > 180) {
        startInput.style.borderColor = 'red';
        stopInput.style.borderColor = 'red';
    } else {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
    }
}

function formatNumber(num){return(Math.round(num*100)/100).toString().replace(/\.00$/,'');}

function resizeOverlay() {
    const rect = vesselImg.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    overlayCanvas.width = size;
    overlayCanvas.height = size;
    overlayCanvas.style.width = size + 'px';
    overlayCanvas.style.height = size + 'px';
    overlayCanvas.style.left = ((rect.width - size) / 2) + 'px';
    overlayCanvas.style.top = ((rect.height - size) / 2) + 'px';
    overlayCtx.setTransform(1, 0, 0, 1, 0, 0);
    drawZones();
}


function drawZones() {
    const blockagePanel = document.getElementById('blockagePanel');
    const rows = zonesBody.querySelectorAll('tr');
    
    blockagePanel.classList.toggle('has-zones', rows.length > 0);

    const ctx = overlayCtx;
    const size = overlayCanvas.width;
    const cx = size / 2;
    const cy = size / 2;
    const R = size * 0.42;

    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    rows.forEach(row => {
        const color = row.dataset.color || '#ff0000';
        const start = parseFloat(row.cells[1].querySelector('input').value) || 0;
        const stop = parseFloat(row.cells[2].querySelector('input').value) || 0;
        const el = Math.min(Math.max(parseFloat(row.cells[3].querySelector('input').value) || 0, 0), 90);
        const opacity = 0.2 + (el / 90) * 0.6;

        const startRad = (start - 90) * Math.PI / 180;
        const stopRad = (stop - 90) * Math.PI / 180;

        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, R, startRad, stopRad, false);
        ctx.closePath();
        ctx.fillStyle = hexToRgba(color, opacity);
        ctx.fill();
        ctx.restore();

        let midAngle = stop < start ?
            ((start - 90) * Math.PI / 180 + (stop + 360 - 90) * Math.PI / 180) / 2 :
            (startRad + stopRad) / 2;

        const labelX = cx + Math.cos(midAngle) * R * 0.7;
        const labelY = cy + Math.sin(midAngle) * R * 0.7;
        ctx.fillStyle = 'black';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(el)}ï¾‚ï½°`, labelX, labelY);
    });
}


document.getElementById('antennaLocation').addEventListener('input', (event) => {
event.target.value = event.target.value.toUpperCase();
});

document.getElementById('submittedBy').addEventListener('change', (event) => {
let value = event.target.value.trim();
let words = value.split(/\s+/);
let formattedWords = words.map(word => {
    if (word.length === 0) return '';
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
});
event.target.value = formattedWords.join(' ');
});

function createZoneRow(start = 0, stop = 0, el = 0) {
    const tr = document.createElement('tr');
    const zoneIndex = zonesBody.children.length;
    const color = ZONE_COLORS[zoneIndex % ZONE_COLORS.length];
    tr.dataset.color = color;
    
    tr.innerHTML = `
    <td><span class="zone-color-swatch" style="background-color: ${color};" title="Zone Color"></span></td>
    <td><input inputmode="decimal" value="${formatNumber(start)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(stop)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(el)}"></td>
    <td><button>X</button></td>
    `;
    
    const inputs = tr.querySelectorAll('input');
    inputs.forEach(input => input.addEventListener('focus', event => event.target.select()));

    const startInput = inputs[0];
    const stopInput = inputs[1];
    const elInput = inputs[2];

    const azHandler = () => {
        validateZoneRow(tr);
        drawZones();
        updatePdfPreview(); // Update preview
    };

    startInput.addEventListener('input', azHandler);
    stopInput.addEventListener('input', azHandler);

    startInput.addEventListener('blur', () => {
        startInput.value = formatNumber(Math.min(Math.max(parseFloat(startInput.value) || 0, 0), 360));
        azHandler();
    });
    stopInput.addEventListener('blur', () => {
        stopInput.value = formatNumber(Math.min(Math.max(parseFloat(stopInput.value) || 0, 0), 360));
        azHandler();
    });

    elInput.addEventListener('input', () => {
        drawZones();
        updatePdfPreview(); // Update preview
    });
    elInput.addEventListener('blur', () => {
        elInput.value = formatNumber(Math.min(Math.max(parseFloat(elInput.value) || 0, 0), 90));
        drawZones();
        updatePdfPreview(); // Update preview
    });

    tr.querySelector('button').addEventListener('click', () => {
        tr.remove();
        drawZones();
        updatePdfPreview(); // Update preview
    });

    zonesBody.appendChild(tr);
    drawZones();
    validateZoneRow(tr);
    updatePdfPreview(); // Update preview
}


document.getElementById('addBlockBtn').addEventListener('click',()=>createZoneRow());

// --------- Drag & Drop 8 Photos -----------
const dropArea=document.getElementById('drop-area');
const fileInput=document.getElementById('fileElem');
["dragenter","dragover","dragleave","drop"].forEach(e=>{
dropArea.addEventListener(e,ev=>{ev.preventDefault();ev.stopPropagation();});
});
["dragenter","dragover"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.add("highlight")));
["dragleave","drop"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.remove("highlight")));
dropArea.addEventListener("drop",e=>handleFiles(e.dataTransfer.files));
fileInput.addEventListener("change",()=>handleFiles(fileInput.files));

const placementOrder=[2,3,6,9,8,7,4,1];

function processImage(file, index) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxSize = 600;
            let { width, height } = img;

            if (width > height) {
                if (width > maxSize) { height *= maxSize / width; width = maxSize; }
            } else {
                if (height > maxSize) { width *= maxSize / height; height = maxSize; }
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            
            const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
            const cell = document.getElementById(`cell-${index}`);
            if (cell) {
                cell.innerHTML = "";
                const imgEl = document.createElement('img');
                imgEl.src = compressedDataUrl;
                cell.appendChild(imgEl);
                updatePdfPreview(); // Update preview
            }
        };
        img.onerror = () => {
            console.error("Error loading image from data URL.");
            alert("Could not load image. Please try a different photo.");
        };
        img.src = e.target.result;
    };
    reader.onerror = function() {
        console.error("FileReader failed to read the file.");
        alert("Failed to read the selected file. Please try again.");
    };
    reader.readAsDataURL(file);
}


function handleFiles(files){Array.from(files).slice(0,8).forEach((file,i)=>processImage(file,placementOrder[i]));}


// --------- One-by-one photo selection -----------
const singleFileElem = document.getElementById('singleFileElem');
let currentCellIndex = null;

function openFilePickerForCell(index) {
    currentCellIndex = index;
    singleFileElem.click();
}

singleFileElem.addEventListener('change', () => {
    if (singleFileElem.files.length > 0 && currentCellIndex) {
        processImage(singleFileElem.files[0], currentCellIndex);
    }
    singleFileElem.value = '';
});

function setupCellClickListeners() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const index = cell.dataset.index;
        const initialNumber = cell.innerHTML.trim();  
        
        cell.removeEventListener('click', handleCellClick);  
        cell.addEventListener('click', handleCellClick);

        function handleCellClick() {
            if (cell.querySelector('img')) {
                if (window.confirm("Replace existing picture? Or click 'Cancel' to remove it.")) {
                    openFilePickerForCell(index);
                } else {
                    cell.innerHTML = initialNumber;
                    updatePdfPreview(); // Update preview
                }
            } else {
                openFilePickerForCell(index);
            }
        }
    });
}
// -------------------------------------------------------------

// --------- Remove All Images Function -----------
function removeAllImages() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const cellMap = {"1": "8", "2": "1", "3": "2", "4": "7", "6": "3", "7": "6", "8": "5", "9": "4"};
        cell.innerHTML = cellMap[cell.dataset.index] || '';
    });
    updatePdfPreview(); // Update preview
}

document.getElementById('removeAllImagesBtn').addEventListener('click', removeAllImages);
// ------------------------------------------------

// --------- PDF Generation & Preview (MERGED) -----------
let generatedCanvas = null;
let previewTimeout;

// NEW Live Preview Function
async function updatePdfPreview() {
    clearTimeout(previewTimeout);
    const previewContainer = document.getElementById('pdf-preview-content');
    
    // Show a simple text loader only if there's no image
    if (!previewContainer.querySelector('img')) {
        previewContainer.innerHTML = 'Updating...';
    }
    
    previewTimeout = setTimeout(async () => {
        try {
            generatedCanvas = await generatePdfContentCanvas(); // Use original hi-fi function
            
            let previewImg = previewContainer.querySelector('img');
            if (!previewImg) {
                previewContainer.innerHTML = ''; // Clear 'Updating...'
                previewImg = document.createElement('img');
                previewContainer.appendChild(previewImg);
            }
            
            previewImg.src = generatedCanvas.toDataURL('image/jpeg', 0.9);

        } catch (err) {
            console.error("Live preview failed:", err);
            previewContainer.innerHTML = '<p style="color:red;">Preview failed to load.</p>';
        }
    }, 300); // 300ms debounce
}

// Original (high-fidelity) PDF content generator
async function generatePdfContentCanvas() {
    const pdfContainer = document.createElement('div');
    pdfContainer.style.width = '720px';
    pdfContainer.style.background = '#fff';
    pdfContainer.style.padding = '10px';
    pdfContainer.style.borderRadius = '8px';
    // Position off-screen
    pdfContainer.style.position = 'absolute';
    pdfContainer.style.left = '-9999px';
    pdfContainer.style.top = '0';


    const vesselNameVal = document.getElementById('vesselName').value.trim();
    const antennaLocVal = document.getElementById('antennaLocation').value.trim();
    const dateVal = document.getElementById('dateInput').value;
    const submittedByVal = document.getElementById('submittedBy').value.trim();

    if (vesselNameVal || antennaLocVal || dateVal || submittedByVal) {
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'display:flex; align-items:center; justify-content:center; margin-bottom:12px;';
        const logoImg = document.createElement('img');
        
        // --- 4. UPDATE JS TO USE CENTRAL LOGO IN GENERATED PDF ---
        logoImg.src = 'https://pgarciafer.github.io/shared-design-system/icons/logo.png';
        // ----------------------------------------------------------
        
        logoImg.style.cssText = 'height:50px; margin-right:12px;';
        // Add crossOrigin to allow canvas export of external image
        logoImg.crossOrigin = "Anonymous";
        
        infoDiv.appendChild(logoImg);
        const textDiv = document.createElement('div');
        textDiv.style.textAlign = 'left';
        if(vesselNameVal) textDiv.innerHTML += `<div><strong>Vessel:</strong> ${vesselNameVal}</div>`;
        if(antennaLocVal) textDiv.innerHTML += `<div><strong>Antenna & Location:</strong> ${antennaLocVal}</div>`;
        if(dateVal) textDiv.innerHTML += `<div><strong>Date:</strong> ${dateVal}</div>`;
        if(submittedByVal) textDiv.innerHTML += `<div><strong>Submitted by:</strong> ${submittedByVal}</div>`;
        infoDiv.appendChild(textDiv);
        pdfContainer.appendChild(infoDiv);
    }
    
    const zonesData = Array.from(zonesBody.querySelectorAll('tr')).map(row => ({
        start: parseFloat(row.cells[1].querySelector('input').value) || 0,
        stop: parseFloat(row.cells[2].querySelector('input').value) || 0,
        el: parseFloat(row.cells[3].querySelector('input').value) || 0,
        color: row.dataset.color || '#ff0000'
    }));

    if (zonesData.length > 0) {
        const gridCanvas = createBlockageGridCanvas(zonesData);
        const gridImg = document.createElement('img');
        gridImg.src = gridCanvas.toDataURL('image/png');
        gridImg.style.cssText = 'display:block; margin:10px auto;';
        pdfContainer.appendChild(gridImg);
    }

    function createBlockageGridCanvas(zones) {
        const cols = 72; const rows = 18; const cellSize = 9; const margin = 20;
        const width = cols * cellSize + margin * 2; const height = rows * cellSize + margin * 2;
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
        ctx.translate(margin, height - margin);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -rows * cellSize); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(cols * cellSize, 0); ctx.stroke();
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 0.5;
        for (let c = 1; c < cols; c++) { const x = c * cellSize; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, -rows * cellSize); ctx.stroke(); }
        for (let r = 1; r < rows; r++) { const y = -r * cellSize; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cols * cellSize, y); ctx.stroke(); }
        
        zones.forEach(zone => {
            ctx.fillStyle = hexToRgba(zone.color, 0.7);
            const elClamped = Math.min(Math.max(zone.el, 0), 90);
            const rowTop = Math.floor((elClamped / 90) * rows);
            const normalizeAz = az => (az < 180 ? 36 + Math.floor(az / 5) : Math.floor((az - 180) / 5));
            const cStart = normalizeAz(zone.start); const cStop = normalizeAz(zone.stop);
            const fillCell = (c, r) => ctx.fillRect(c * cellSize, -r * cellSize - cellSize, cellSize, cellSize);
            if (cStart <= cStop) { for (let c = cStart; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); }  
            else { for (let c = cStart; c < cols; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); for (let c = 0; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); }
        });

        ctx.fillStyle = '#000'; ctx.font = '8px sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let az = 180; az <= 540; az += 10) {
            let colIndex = az <= 360 ? (az - 180) / 5 : (az - 540) / 5 + 72;
            const x = colIndex * cellSize; if (x < 0 || x > cols * cellSize) continue;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 3); ctx.stroke();
            ctx.save(); ctx.translate(x, 6); ctx.rotate(-Math.PI / 4); ctx.fillText((az % 360).toString(), 0, 0); ctx.restore();
        }
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let el = 0; el <= 90; el += 5) { const y = -(el / 90) * rows * cellSize; ctx.beginPath(); ctx.moveTo(-3, y); ctx.lineTo(0, y); ctx.stroke(); ctx.fillText(el.toString(), -8, y); }
        return canvas;
    }

    async function createVesselCanvasForPDF(zones) {
        const img = new Image(); img.crossOrigin = "anonymous"; img.src = 'https://pgarciafer.github.io/satcalc/IMG_0585.PNG';
        await new Promise(resolve => img.onload = resolve);
        const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
        const size = Math.min(img.naturalWidth, img.naturalHeight); const cx = img.naturalWidth / 2; const cy = img.naturalHeight / 2; const R = size * 0.42;
        zones.forEach(zone => {
            if (isNaN(zone.start) || isNaN(zone.stop)) return;
            const startRad = (zone.start - 90) * Math.PI / 180; const stopRad = (zone.stop - 90) * Math.PI / 180;
            const elClamped = Math.min(Math.max(zone.el, 0), 90); const opacity = 0.2 + (elClamped / 90) * 0.6;
            ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, R, startRad, stopRad, false); ctx.closePath(); ctx.fillStyle = hexToRgba(zone.color, opacity); ctx.fill();
            ctx.restore();
            let midAngle = (zone.stop < zone.start) ? ((zone.start - 90) * Math.PI / 180 + (zone.stop + 360 - 90) * Math.PI / 180) / 2 : (startRad + stopRad) / 2;
            const labelX = cx + Math.cos(midAngle) * R * 0.7; const labelY = cy + Math.sin(midAngle) * R * 0.7;
            ctx.fillStyle = 'black'; ctx.font = '28px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${Math.round(zone.el)}ï¾‚ï½°`, labelX, labelY);
        });
        return canvas;
    }

    const gridClone = document.getElementById('grid').cloneNode(true);
    const centerCellClone = gridClone.querySelector('#cell-5');
    centerCellClone.innerHTML = '';
    const vesselCanvas = await createVesselCanvasForPDF(zonesData);
    const imgEl = document.createElement('img');
    imgEl.src = vesselCanvas.toDataURL('image/png');
    centerCellClone.appendChild(imgEl);

    pdfContainer.appendChild(gridClone);
    document.body.appendChild(pdfContainer);
    
    const canvas = await html2canvas(pdfContainer, { scale: 2, useCORS: true });
    
    pdfContainer.remove();
    return canvas;
}

// --- THIS FUNCTION IS UPDATED ---
async function downloadPdf() {
    if (!generatedCanvas) {
        alert("Preview data not found. Please generate the preview again.");
        return;
    }

    try {
        const vesselNameVal = document.getElementById('vesselName').value.trim();
        const antennaLocVal = document.getElementById('antennaLocation').value.trim();
        const dateVal = document.getElementById('dateInput').value;
        const cleanDate = dateVal.replace(/-/g, '');
        const fileName = `${vesselNameVal}_BlockageChart_${antennaLocVal}_${cleanDate}.pdf`.replace(/[\/\\?%*:|"<>]/g, '_');

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const imgData = generatedCanvas.toDataURL('image/jpeg', 0.95);
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const ratio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth;
        let imgHeight = imgWidth / ratio;
        let posY = (pdfHeight - imgHeight > 0) ? (pdfHeight - imgHeight) / 2 : 0;

        // On very tall (unlikely) images, fit to height instead
        if (imgHeight > pdfHeight) {
            imgHeight = pdfHeight;
            imgWidth = imgHeight * ratio;
            posY = 0;
        }

        pdf.addImage(imgData, 'JPEG', 0, posY, imgWidth, imgHeight);

        // --- NEW LOGIC ---
        // Add a simple mobile check
        const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);

        // Use Web Share API on mobile if available
        if (isMobile && navigator.share && navigator.canShare) {
            const pdfBlob = pdf.output('blob');
            const pdfFile = new File([pdfBlob], fileName, { type: 'application/pdf' });

            await navigator.share({
                // title: 'Blockage Chart', // Removed to prevent .txt file on iOS
                files: [pdfFile]
            });
            return; // Successfully shared, no download needed.
        } else {
            // --- FALLBACK LOGIC ---
            // On desktop, or if share is unavailable, download directly.
            pdf.save(fileName);
        }
        
    } catch (err) {
        if (err.name === 'AbortError') {
            // This happens if the user cancels the share sheet. It's not a real error.
            console.log("Share cancelled by user.");
        } else {
            console.error("PDF generation/share failed:", err);
            alert("PDF generation or sharing failed. Please check the console for details.");
        }
    }
}
// --- END OF UPDATED FUNCTION ---


// Replaced modal button listeners with direct download
document.getElementById('generatePdf').addEventListener('click', downloadPdf);
// downloadPdfBtn.addEventListener('click', downloadPdf); // Removed

// Add live preview listeners for header inputs
document.getElementById('vesselName').addEventListener('input', updatePdfPreview);
document.getElementById('antennaLocation').addEventListener('input', updatePdfPreview);
document.getElementById('dateInput').addEventListener('input', updatePdfPreview);
document.getElementById('submittedBy').addEventListener('input', updatePdfPreview);


document.getElementById('vesselName').addEventListener('change', (event) => {
    let value = event.target.value.trim();
    const prefixRegex = /^[A-Z]{3}_/;
    let prefix = '';
    let namePart = value;

    if (prefixRegex.test(value)) {
        prefix = value.substring(0, 4);
        namePart = value.substring(4);
    } else if (value.length >= 3) {
        prefix = value.substring(0, 3).toUpperCase() + '_';
        namePart = value.substring(3);
    }

    let words = namePart.split(/\s+/);
    let formattedWords = words.map(word => {
        if (word.length === 0) return '';
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    });

    event.target.value = prefix + formattedWords.join('');
});

window.addEventListener('resize', resizeOverlay);
window.addEventListener('DOMContentLoaded',() => {
    resizeOverlay();
    setupCellClickListeners();
    document.querySelectorAll('.header-inputs input').forEach(input => {
        input.addEventListener('focus', event => event.target.select());
    });
    
    // --------- VOICE INPUT SCRIPT -----------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    let activeMicButton = null;
    const originalPlaceholders = {};

    function startListening(event) {
        if (activeMicButton) {
            recognition.stop();
            return;
        }
        const btn = event.currentTarget;
        const targetId = btn.dataset.target;
        const targetInput = document.getElementById(targetId);
        if (!targetInput) return;
        
        activeMicButton = btn;
        
        document.querySelectorAll('.mic-btn').forEach(b => b.disabled = true);
        btn.disabled = false;
        btn.classList.add('listening');
        targetInput.placeholder = 'Listening...';

        recognition.start();
    }

    function handleRecognitionResult(event) {
        const transcript = event.results[0][0].transcript;
        const targetId = activeMicButton.dataset.target;
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            targetInput.value = transcript;
            targetInput.dispatchEvent(new Event('change', { bubbles: true }));
            targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    function handleRecognitionError(event) {
        console.error('Speech recognition error', event.error);
        let errorMessage = `An unknown speech recognition error occurred: ${event.error}`;
        
        switch (event.error) {
            case 'audio-capture':
                errorMessage = "Could not start voice input. Please ensure your microphone is connected and that you've allowed this site to access it. You might need to check your browser's permission settings in the address bar.";
                break;
            case 'not-allowed':
                errorMessage = "Voice input is disabled. You need to grant microphone permissions for this site. Please click the microphone icon in your address bar and allow access.";
                break;
            case 'no-speech':
                errorMessage = "No speech was detected. Please try speaking again.";
                break;
            case 'network':
                errorMessage = "A network error occurred during speech recognition. Please check your internet connection.";
                break;
            case 'service-not-allowed':
                 errorMessage = "Voice input service is not allowed. This might be due to your browser or system settings.";
                 break;
        }
        
        alert(errorMessage);
    }

    function handleRecognitionEnd() {
        if (!activeMicButton) return;
        const targetId = activeMicButton.dataset.target;
        const targetInput = document.getElementById(targetId);
        
        activeMicButton.classList.remove('listening');
        document.querySelectorAll('.mic-btn').forEach(b => b.disabled = false);
        
        if (targetInput) {
            targetInput.placeholder = originalPlaceholders[targetId] || '';
        }
        activeMicButton = null;
    }

    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onresult = handleRecognitionResult;
        recognition.onerror = handleRecognitionError;
        recognition.onend = handleRecognitionEnd;

        document.querySelectorAll('.mic-btn').forEach(btn => {
            const targetId = btn.dataset.target;
            const targetInput = document.getElementById(targetId);
            if (targetInput) {
                originalPlaceholders[targetId] = targetInput.placeholder;
            }
            btn.addEventListener('click', startListening);
        });
    } else {
        console.warn('Speech Recognition API not supported in this browser.');
        document.querySelectorAll('.mic-btn').forEach(btn => btn.style.display = 'none');
    }
    // --------- END VOICE INPUT SCRIPT -----------

    updatePdfPreview(); // Load initial preview
});
</script>
</body>
</html>

}
