<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blockage Chart</title>
<link rel="icon" href="https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo1.png" type="image/png">
<style>
:root {
  --primary-color: #005A9C;
  --primary-hover: #004a80;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --success-color: #28a745;
  --success-hover: #218838;
  --bg-color: #f8f9fa;
  --container-bg: #ffffff;
  --text-color: #212529;
  --text-muted: #6c757d;
  --border-color: #dee2e6;
  --card-shadow: 0 4px 12px rgba(0,0,0,0.08);
  --input-focus-shadow: 0 0 0 0.25rem rgba(0, 90, 156, 0.25);
  --input-invalid-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
}

*, *::before, *::after {
  box-sizing: border-box;
}

body {
  font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: var(--bg-color);
  margin: 0;
  padding: 24px;
  min-height: 100vh;
  color: var(--text-color);
  text-align: center;
}

body.modal-open {
    overflow: hidden;
}

.card {
  max-width: 950px;
  margin: auto;
  padding: 24px;
  background: var(--container-bg);
  border-radius: 8px;
  box-shadow: var(--card-shadow);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

.main-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--border-color);
}

#pageLogo {
    height: 60px;
    display: block;
}

h1 {
    margin: 0;
    color: var(--primary-color);
    font-size: 24px;
    font-weight: 600;
    letter-spacing: -0.5px;
}

label {
  display: block;
  margin-top: 16px;
  margin-bottom: 8px;
  font-weight: 500;
  color: var(--text-muted);
  font-size: 14px;
  text-align: left;
}

input, select {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  font-size: 15px;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  background-color: #fff;
  color: var(--text-color);
}

input:focus, select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: var(--input-focus-shadow);
}

.header-inputs {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
}
.header-inputs input {
    padding: 10px; /* Use standard padding */
}
#vesselName { width: 220px; }
#antennaLocation { width: 260px; }
#dateInput { width: 150px; }
#submittedBy { width: 220px; }


#drop-area {
  border: 2px dashed var(--border-color);
  background: #fafcff;
  padding: 20px;
  text-align: center;
  cursor: pointer;
  border-radius: 12px;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 120px;
  margin-bottom: 12px; 
  box-sizing: border-box;
}

#drop-area:hover, #drop-area.highlight {
  border-color: var(--primary-color);
  background: #f0f6ff;
}
#drop-area p {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 0;
}

.content-wrapper {
    max-width: 650px;
    margin: 20px auto 0;
}

.button-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    margin-top: 25px;
}

.button-container button {
    width: 60%;
    max-width: 350px;
    margin-top: 0;
}

#grid {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    margin: 0;
    background: white;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    position: relative;
    box-sizing: border-box;
}

.cell {
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    display:flex;
    justify-content:center;
    align-items:center;
    overflow:hidden;
    position:relative;
    border-radius:6px;
    cursor:pointer;
    font-size: 2.5rem;
    font-weight: bold;
    color: #ccc;
}
.cell img {
    width:100%;
    height:100%;
    object-fit:cover;
}
.cell:has(img) {
    font-size: 0;
    border: 1px solid #aaa;
}

.center-cell {
    background:white;
    position:relative;
    cursor: default;
    border: none;
}

.center-cell .cell-number {
    display: none;
}

button {
  padding: 10px 16px;
  border: 1px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  transition: background-color 0.15s ease-in-out, transform 0.1s ease;
  position: relative;
  -webkit-appearance: none;
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
  transform: none;
  opacity: 0.7;
}

button:active:not(:disabled) {
  transform: scale(0.98);
}

#addBlockBtn, #generatePdf {
    background-color: var(--primary-color);
    color: white;
    border: none;
}
#addBlockBtn:hover:not(:disabled), #generatePdf:hover:not(:disabled) {
  background-color: var(--primary-hover);
}

#removeAllImagesBtn {
    background-color: white;
    color: var(--danger-color);
    border: 1px solid var(--danger-color);
    transition: background-color 0.2s, color 0.2s;
}
#removeAllImagesBtn:hover:not(:disabled) {
    background-color: var(--danger-color);
    color: white;
}
table{width:100%; border-collapse:collapse; margin-top:8px;}
th, td{padding:8px 6px; text-align:center; border-bottom:1px solid var(--border-color);}
th { color: var(--text-muted); font-size: 14px; font-weight: 500; }
#zonesTable td button{
  background: var(--danger-color);
  color:white;
  border-radius:4px;
  border:none;
  padding:4px 8px;
  font-weight: bold;
  font-size: 14px;
}
#zonesTable td button:hover {
  background: var(--danger-hover);
}
#zonesTable input {
  width: 100%;
  padding: 6px;
  text-align: center;
  box-sizing: border-box;
}

.zone-color-swatch {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: 1px solid rgba(0,0,0,0.1);
  vertical-align: middle;
}
.pdfTable { width:60%; border-collapse:collapse; margin: 0 auto 12px; }
.pdfTable th, .pdfTable td { border:1px solid #aaa; padding:4px; text-align:center; }

#vesselImage {
    position: relative;
    width: 100%;
    height: 100%;
    background-image: url('https://pgarciafer.github.io/satcalc/IMG_0585.PNG');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    filter: drop-shadow(0 4px 12px rgba(0,0,0,0.35));
}
#overlayCanvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }


@media screen and (max-width: 600px) {
    body { padding: 10px; }
    .card { padding: 12px; }

    .main-header {
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
        padding-bottom: 20px;
    }
    h1 {
        font-size: 1.5rem; /* 24px */
    }

    .header-inputs {
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }
    .header-inputs input {
        width: 100%;
        box-sizing: border-box;
    }
    
    #vesselName, #antennaLocation, #submittedBy {
        width: 100%;
    }
    #dateInput {
        width: 85%;
    }

    #zonesTable td {
        padding: 4px 2px;
    }
    #zonesTable input {
        font-size: 16px;
    }
    
    .button-container button {
        width: 100%;
        box-sizing: border-box;
    }

    #grid {
        width: 100%;
        height: auto;
        aspect-ratio: 1 / 1;
    }
}

#blockagePanel:not(.has-zones) > label,
#blockagePanel:not(.has-zones) #zonesTable thead {
    display: none;
}

.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Modal styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.6);
    animation: fadeIn 0.3s;
}

.modal-content {
    background-color: #fefefe;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 800px;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    animation: slideIn 0.3s;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 10px;
    border-bottom: 1px solid #ddd;
}

.modal-header h2 {
    margin: 0;
    font-size: 20px;
    color: var(--primary-color);
}

.close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover, .close-button:focus {
    color: black;
    text-decoration: none;
}

.modal-body {
    padding: 20px 0;
    text-align: center;
    min-height: 100px;
}

#previewImage {
    max-width: 100%;
    border: 1px solid #ddd;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.modal-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    padding-top: 10px;
    border-top: 1px solid #ddd;
}

#downloadPdfBtn {
    background-color: var(--success-color);
    color: white;
}
#closeModalBtn {
    background-color: var(--secondary-color);
    color: white;
}
#downloadPdfBtn:hover:not(:disabled) {
    background-color: var(--success-hover);
}
#closeModalBtn:hover {
    background-color: var(--secondary-hover);
}

.loader {
    border: 8px solid #f3f3f3;
    border-top: 8px solid var(--primary-color);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
    margin: 20px auto;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from { transform: translateY(-50px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}
</style>




</head>
<body>
<div class="card">
  <div class="main-header">
    <img src="https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo.png" alt="MTN Logo" id="pageLogo">
    <h1>Blockage Chart</h1>
  </div>

  <div class="header-inputs">
    <input id="vesselName" type="text" placeholder="3LC_VesselName">
    <input id="antennaLocation" type="text" placeholder="Antenna & Location">
    <input id="dateInput" type="date">  
    <input id="submittedBy" type="text" placeholder="Tech Name">
  </div>

  <div class="content-wrapper">
    <div class="controls">
      <div class="panel" id="blockagePanel">
        <label>Blockage Zones (AZ Start / AZ Stop in degrees)</label>
        <table id="zonesTable">
          <thead><tr><th></th><th>AZ Start</th><th>AZ Stop</th><th>EL</th><th></th></tr></thead>
          <tbody id="zonesBody"></tbody>
        </table>
        <div style="margin-top:8px;font-size:13px;color:#536878">
          Add zones and they will be drawn over the center vessel. They are also included in the PDF.
        </div>
      </div>
    </div>

    <div class="button-container">
        <button id="addBlockBtn">Add Blockage Zone</button>
        <button id="generatePdf">Generate PDF</button>
        <button id="removeAllImagesBtn">Remove All Images</button>
    </div>

    <label for="fileElem" id="drop-area">
      <p>📸 Drop up to 8 photos here or click to browse</p>
    </label>
    <input type="file" id="fileElem" accept="image/*" multiple class="visually-hidden">

    <div id="grid">
      <div class="cell" id="cell-1" data-index="1">8</div>
      <div class="cell" id="cell-2" data-index="2">1</div>
      <div class="cell" id="cell-3" data-index="3">2</div>
      
      <div class="cell" id="cell-4" data-index="4">7</div>
      <div class="cell center-cell" id="cell-5" data-index="5">
        <div id="vesselImage">
          <canvas id="overlayCanvas"></canvas>
        </div>
      </div>
      <div class="cell" id="cell-6" data-index="6">3</div>
      
      <div class="cell" id="cell-7" data-index="7">6</div>
      <div class="cell" id="cell-8" data-index="8">5</div>
      <div class="cell" id="cell-9" data-index="9">4</div>
    </div>
  </div>

  <input type="file" id="singleFileElem" accept="image/*" class="visually-hidden">
</div>

<div id="previewModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>PDF Preview</h2>
      <span class="close-button">&times;</span>
    </div>
    <div class="modal-body">
        <div id="loader" class="loader"></div>
        <img id="previewImage" src="" alt="PDF Preview" style="display: none;">
    </div>
    <div class="modal-footer">
      <button id="downloadPdfBtn" disabled>Download PDF</button>
      <button id="closeModalBtn">Close</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// Set default date to today
const today = new Date();
const yyyy = today.getFullYear();
const mm = String(today.getMonth()+1).padStart(2,'0');
const dd = String(today.getDate()).padStart(2,'0');
document.getElementById('dateInput').value = `${yyyy}-${mm}-${dd}`;

// --------- Blockage Zones -----------
const ZONE_COLORS = ['#E53935','#1E88E5','#43A047','#FB8C00','#8E24AA','#D81B60','#00ACC1','#FDD835'];
const zonesBody=document.getElementById('zonesBody');
const overlayCanvas=document.getElementById('overlayCanvas');
const overlayCtx=overlayCanvas.getContext('2d');
const vesselImg=document.getElementById('vesselImage');

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function validateZoneRow(tr) {
    const startInput = tr.cells[1].querySelector('input');
    const stopInput = tr.cells[2].querySelector('input');
    const start = parseFloat(startInput.value);
    const stop = parseFloat(stopInput.value);

    if (isNaN(start) || isNaN(stop)) {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
        return;
    }

    let angle = stop - start;
    if (angle < 0) {
        angle += 360; // Assumes wrap-around
    }

    if (angle > 180) {
        startInput.style.borderColor = 'red';
        stopInput.style.borderColor = 'red';
    } else {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
    }
}

function formatNumber(num){return(Math.round(num*100)/100).toString().replace(/\.00$/,'');}

function resizeOverlay() {
    const rect = vesselImg.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    overlayCanvas.width = size;
    overlayCanvas.height = size;
    overlayCanvas.style.width = size + 'px';
    overlayCanvas.style.height = size + 'px';
    overlayCanvas.style.left = ((rect.width - size) / 2) + 'px';
    overlayCanvas.style.top = ((rect.height - size) / 2) + 'px';
    overlayCtx.setTransform(1, 0, 0, 1, 0, 0);
    drawZones();
}


function drawZones() {
    const blockagePanel = document.getElementById('blockagePanel');
    const rows = zonesBody.querySelectorAll('tr');
    
    blockagePanel.classList.toggle('has-zones', rows.length > 0);

    const ctx = overlayCtx;
    const size = overlayCanvas.width;
    const cx = size / 2;
    const cy = size / 2;
    const R = size * 0.42;

    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    rows.forEach(row => {
        const color = row.dataset.color || '#ff0000';
        const start = parseFloat(row.cells[1].querySelector('input').value) || 0;
        const stop = parseFloat(row.cells[2].querySelector('input').value) || 0;
        const el = Math.min(Math.max(parseFloat(row.cells[3].querySelector('input').value) || 0, 0), 90);
        const opacity = 0.2 + (el / 90) * 0.6;

        const startRad = (start - 90) * Math.PI / 180;
        const stopRad = (stop - 90) * Math.PI / 180;

        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, R, startRad, stopRad, false);
        ctx.closePath();
        ctx.fillStyle = hexToRgba(color, opacity);
        ctx.fill();
        ctx.restore();

        let midAngle = stop < start ?
            ((start - 90) * Math.PI / 180 + (stop + 360 - 90) * Math.PI / 180) / 2 :
            (startRad + stopRad) / 2;

        const labelX = cx + Math.cos(midAngle) * R * 0.7;
        const labelY = cy + Math.sin(midAngle) * R * 0.7;
        ctx.fillStyle = 'black';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(el)}°`, labelX, labelY);
    });
}


document.getElementById('antennaLocation').addEventListener('input', (event) => {
event.target.value = event.target.value.toUpperCase();
});

document.getElementById('submittedBy').addEventListener('change', (event) => {
let value = event.target.value.trim();
let words = value.split(/\s+/);
let formattedWords = words.map(word => {
    if (word.length === 0) return '';
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
});
event.target.value = formattedWords.join(' ');
});

function createZoneRow(start = 0, stop = 0, el = 0) {
    const tr = document.createElement('tr');
    const zoneIndex = zonesBody.children.length;
    const color = ZONE_COLORS[zoneIndex % ZONE_COLORS.length];
    tr.dataset.color = color;
    
    tr.innerHTML = `
    <td><span class="zone-color-swatch" style="background-color: ${color};" title="Zone Color"></span></td>
    <td><input inputmode="decimal" value="${formatNumber(start)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(stop)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(el)}"></td>
    <td><button>X</button></td>
    `;
    
    const inputs = tr.querySelectorAll('input');
    inputs.forEach(input => input.addEventListener('focus', event => event.target.select()));

    const startInput = inputs[0];
    const stopInput = inputs[1];
    const elInput = inputs[2];

    const azHandler = () => {
        validateZoneRow(tr);
        drawZones();
    };

    startInput.addEventListener('input', azHandler);
    stopInput.addEventListener('input', azHandler);

    startInput.addEventListener('blur', () => {
        startInput.value = formatNumber(Math.min(Math.max(parseFloat(startInput.value) || 0, 0), 360));
        azHandler();
    });
    stopInput.addEventListener('blur', () => {
        stopInput.value = formatNumber(Math.min(Math.max(parseFloat(stopInput.value) || 0, 0), 360));
        azHandler();
    });

    elInput.addEventListener('input', drawZones);
    elInput.addEventListener('blur', () => {
        elInput.value = formatNumber(Math.min(Math.max(parseFloat(elInput.value) || 0, 0), 90));
        drawZones();
    });

    tr.querySelector('button').addEventListener('click', () => {
        tr.remove();
        drawZones();
    });

    zonesBody.appendChild(tr);
    drawZones();
    validateZoneRow(tr);
}


document.getElementById('addBlockBtn').addEventListener('click',()=>createZoneRow());

// --------- Drag & Drop 8 Photos -----------
const dropArea=document.getElementById('drop-area');
const fileInput=document.getElementById('fileElem');
["dragenter","dragover","dragleave","drop"].forEach(e=>{
dropArea.addEventListener(e,ev=>{ev.preventDefault();ev.stopPropagation();});
});
["dragenter","dragover"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.add("highlight")));
["dragleave","drop"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.remove("highlight")));
dropArea.addEventListener("drop",e=>handleFiles(e.dataTransfer.files));
fileInput.addEventListener("change",()=>handleFiles(fileInput.files));

const placementOrder=[2,3,6,9,8,7,4,1];

function processImage(file, index) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxSize = 600;
            let { width, height } = img;

            if (width > height) {
                if (width > maxSize) { height *= maxSize / width; width = maxSize; }
            } else {
                if (height > maxSize) { width *= maxSize / height; height = maxSize; }
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            
            const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
            const cell = document.getElementById(`cell-${index}`);
            if (cell) {
                cell.innerHTML = "";
                const imgEl = document.createElement('img');
                imgEl.src = compressedDataUrl;
                cell.appendChild(imgEl);
            }
        };
        img.onerror = () => {
            console.error("Error loading image from data URL.");
            alert("Could not load image. Please try a different photo.");
        };
        img.src = e.target.result;
    };
    reader.onerror = function() {
        console.error("FileReader failed to read the file.");
        alert("Failed to read the selected file. Please try again.");
    };
    reader.readAsDataURL(file);
}


function handleFiles(files){Array.from(files).slice(0,8).forEach((file,i)=>processImage(file,placementOrder[i]));}


// --------- One-by-one photo selection -----------
const singleFileElem = document.getElementById('singleFileElem');
let currentCellIndex = null;

function openFilePickerForCell(index) {
    currentCellIndex = index;
    singleFileElem.click();
}

singleFileElem.addEventListener('change', () => {
    if (singleFileElem.files.length > 0 && currentCellIndex) {
        processImage(singleFileElem.files[0], currentCellIndex);
    }
    singleFileElem.value = '';
});

function setupCellClickListeners() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const index = cell.dataset.index;
        const initialNumber = cell.innerHTML.trim(); 
        
        cell.removeEventListener('click', handleCellClick); 
        cell.addEventListener('click', handleCellClick);

        function handleCellClick() {
            if (cell.querySelector('img')) {
                if (window.confirm("Replace existing picture? Or click 'Cancel' to remove it.")) {
                    openFilePickerForCell(index);
                } else {
                    cell.innerHTML = initialNumber;
                }
            } else {
                openFilePickerForCell(index);
            }
        }
    });
}
// -------------------------------------------------------------

// --------- Remove All Images Function -----------
function removeAllImages() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const cellMap = {"1": "8", "2": "1", "3": "2", "4": "7", "6": "3", "7": "6", "8": "5", "9": "4"};
        cell.innerHTML = cellMap[cell.dataset.index] || '';
    });
}

document.getElementById('removeAllImagesBtn').addEventListener('click', removeAllImages);
// ------------------------------------------------

// --------- PDF Generation & Preview -----------
const previewModal = document.getElementById('previewModal');
const closeModalBtn = document.getElementById('closeModalBtn');
const closeButton = previewModal.querySelector('.close-button');
const downloadPdfBtn = document.getElementById('downloadPdfBtn');
const loader = document.getElementById('loader');
const previewImage = document.getElementById('previewImage');

let generatedCanvas = null;

function openModal() {
    previewModal.style.display = 'block';
    document.body.classList.add('modal-open');
}

function closeModal() {
    previewModal.style.display = 'none';
    document.body.classList.remove('modal-open');
    previewImage.src = '';
    previewImage.style.display = 'none';
    loader.style.display = 'block';
    downloadPdfBtn.disabled = true;
    generatedCanvas = null;
}

closeModalBtn.addEventListener('click', closeModal);
closeButton.addEventListener('click', closeModal);
window.addEventListener('click', (event) => {
    if (event.target == previewModal) closeModal();
});

async function generatePdfContentCanvas() {
    const pdfContainer = document.createElement('div');
    pdfContainer.style.width = '720px';
    pdfContainer.style.background = '#fff';
    pdfContainer.style.padding = '10px';
    pdfContainer.style.borderRadius = '8px';

    const vesselNameVal = document.getElementById('vesselName').value.trim();
    const antennaLocVal = document.getElementById('antennaLocation').value.trim();
    const dateVal = document.getElementById('dateInput').value;
    const submittedByVal = document.getElementById('submittedBy').value.trim();

    if (vesselNameVal || antennaLocVal || dateVal || submittedByVal) {
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'display:flex; align-items:center; justify-content:center; margin-bottom:12px;';
        const logoImg = document.createElement('img');
        logoImg.src = 'https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo.png';
        logoImg.style.cssText = 'height:50px; margin-right:12px;';
        infoDiv.appendChild(logoImg);
        const textDiv = document.createElement('div');
        textDiv.style.textAlign = 'left';
        if(vesselNameVal) textDiv.innerHTML += `<div><strong>Vessel:</strong> ${vesselNameVal}</div>`;
        if(antennaLocVal) textDiv.innerHTML += `<div><strong>Antenna & Location:</strong> ${antennaLocVal}</div>`;
        if(dateVal) textDiv.innerHTML += `<div><strong>Date:</strong> ${dateVal}</div>`;
        if(submittedByVal) textDiv.innerHTML += `<div><strong>Submitted by:</strong> ${submittedByVal}</div>`;
        infoDiv.appendChild(textDiv);
        pdfContainer.appendChild(infoDiv);
    }
    
    const zonesData = Array.from(zonesBody.querySelectorAll('tr')).map(row => ({
        start: parseFloat(row.cells[1].querySelector('input').value) || 0,
        stop: parseFloat(row.cells[2].querySelector('input').value) || 0,
        el: parseFloat(row.cells[3].querySelector('input').value) || 0,
        color: row.dataset.color || '#ff0000'
    }));

    if (zonesData.length > 0) {
        const gridCanvas = createBlockageGridCanvas(zonesData);
        const gridImg = document.createElement('img');
        gridImg.src = gridCanvas.toDataURL('image/png');
        gridImg.style.cssText = 'display:block; margin:10px auto;';
        pdfContainer.appendChild(gridImg);
    }

    function createBlockageGridCanvas(zones) {
        const cols = 72; const rows = 18; const cellSize = 9; const margin = 20;
        const width = cols * cellSize + margin * 2; const height = rows * cellSize + margin * 2;
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
        ctx.translate(margin, height - margin);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -rows * cellSize); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(cols * cellSize, 0); ctx.stroke();
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 0.5;
        for (let c = 1; c < cols; c++) { const x = c * cellSize; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, -rows * cellSize); ctx.stroke(); }
        for (let r = 1; r < rows; r++) { const y = -r * cellSize; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cols * cellSize, y); ctx.stroke(); }
        
        zones.forEach(zone => {
            ctx.fillStyle = hexToRgba(zone.color, 0.7);
            const elClamped = Math.min(Math.max(zone.el, 0), 90);
            const rowTop = Math.floor((elClamped / 90) * rows);
            const normalizeAz = az => (az < 180 ? 36 + Math.floor(az / 5) : Math.floor((az - 180) / 5));
            const cStart = normalizeAz(zone.start); const cStop = normalizeAz(zone.stop);
            const fillCell = (c, r) => ctx.fillRect(c * cellSize, -r * cellSize - cellSize, cellSize, cellSize);
            if (cStart <= cStop) { for (let c = cStart; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); } 
            else { for (let c = cStart; c < cols; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); for (let c = 0; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); }
        });

        ctx.fillStyle = '#000'; ctx.font = '8px sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let az = 180; az <= 540; az += 10) {
            let colIndex = az <= 360 ? (az - 180) / 5 : (az - 540) / 5 + 72;
            const x = colIndex * cellSize; if (x < 0 || x > cols * cellSize) continue;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 3); ctx.stroke();
            ctx.save(); ctx.translate(x, 6); ctx.rotate(-Math.PI / 4); ctx.fillText((az % 360).toString(), 0, 0); ctx.restore();
        }
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let el = 0; el <= 90; el += 5) { const y = -(el / 90) * rows * cellSize; ctx.beginPath(); ctx.moveTo(-3, y); ctx.lineTo(0, y); ctx.stroke(); ctx.fillText(el.toString(), -8, y); }
        return canvas;
    }

    async function createVesselCanvasForPDF(zones) {
        const img = new Image(); img.crossOrigin = "anonymous"; img.src = 'https://pgarciafer.github.io/satcalc/IMG_0585.PNG';
        await new Promise(resolve => img.onload = resolve);
        const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
        const size = Math.min(img.naturalWidth, img.naturalHeight); const cx = img.naturalWidth / 2; const cy = img.naturalHeight / 2; const R = size * 0.42;
        zones.forEach(zone => {
            if (isNaN(zone.start) || isNaN(zone.stop)) return;
            const startRad = (zone.start - 90) * Math.PI / 180; const stopRad = (zone.stop - 90) * Math.PI / 180;
            const elClamped = Math.min(Math.max(zone.el, 0), 90); const opacity = 0.2 + (elClamped / 90) * 0.6;
            ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, R, startRad, stopRad, false); ctx.closePath(); ctx.fillStyle = hexToRgba(zone.color, opacity); ctx.fill();
            ctx.restore();
            let midAngle = (zone.stop < zone.start) ? ((zone.start - 90) * Math.PI / 180 + (zone.stop + 360 - 90) * Math.PI / 180) / 2 : (startRad + stopRad) / 2;
            const labelX = cx + Math.cos(midAngle) * R * 0.7; const labelY = cy + Math.sin(midAngle) * R * 0.7;
            ctx.fillStyle = 'black'; ctx.font = '28px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${Math.round(zone.el)}°`, labelX, labelY);
        });
        return canvas;
    }

    const gridClone = document.getElementById('grid').cloneNode(true);
    const centerCellClone = gridClone.querySelector('#cell-5');
    centerCellClone.innerHTML = '';
    const vesselCanvas = await createVesselCanvasForPDF(zonesData);
    const imgEl = document.createElement('img');
    imgEl.src = vesselCanvas.toDataURL('image/png');
    centerCellClone.appendChild(imgEl);

    pdfContainer.appendChild(gridClone);
    document.body.appendChild(pdfContainer);
    
    const canvas = await html2canvas(pdfContainer, { scale: 2, useCORS: true });
    
    pdfContainer.remove();
    return canvas;
}

async function showPdfPreview() {
    openModal();
    try {
        generatedCanvas = await generatePdfContentCanvas();
        previewImage.src = generatedCanvas.toDataURL('image/jpeg', 0.95);
        loader.style.display = 'none';
        previewImage.style.display = 'block';
        downloadPdfBtn.disabled = false;
    } catch (err) {
        console.error("Preview generation failed:", err);
        closeModal();
        alert("PDF preview failed. Please check the console for details.");
    }
}

function downloadPdf() {
    if (!generatedCanvas) {
        alert("Preview data not found. Please generate the preview again.");
        return;
    }
    try {
        const imgData = generatedCanvas.toDataURL('image/jpeg', 0.95);
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const ratio = imgProps.width / imgProps.height;
        const imgWidth = pdfWidth;
        const imgHeight = imgWidth / ratio;
        const posY = (pdfHeight - imgHeight > 0) ? (pdfHeight - imgHeight) / 2 : 0;
        pdf.addImage(imgData, 'JPEG', 0, posY, imgWidth, imgHeight);

        const vesselNameVal = document.getElementById('vesselName').value.trim();
        const antennaLocVal = document.getElementById('antennaLocation').value.trim();
        const dateVal = document.getElementById('dateInput').value;
        const cleanDate = dateVal.replace(/-/g, '');
        const fileName = `${vesselNameVal}_BlockageChart_${antennaLocVal}_${cleanDate}.pdf`.replace(/[\/\\?%*:|"<>]/g, '_');

        pdf.save(fileName);
        closeModal();
    } catch (err) {
        console.error("PDF download failed:", err);
        alert("PDF download failed. Please check the console for details.");
    }
}


document.getElementById('generatePdf').addEventListener('click', showPdfPreview);
downloadPdfBtn.addEventListener('click', downloadPdf);


document.getElementById('vesselName').addEventListener('change', (event) => {
    let value = event.target.value.trim();
    const prefixRegex = /^[A-Z]{3}_/;
    let prefix = '';
    let namePart = value;

    if (prefixRegex.test(value)) {
        prefix = value.substring(0, 4);
        namePart = value.substring(4);
    } else if (value.length >= 3) {
        prefix = value.substring(0, 3).toUpperCase() + '_';
        namePart = value.substring(3);
    }

    let words = namePart.split(/\s+/);
    let formattedWords = words.map(word => {
        if (word.length === 0) return '';
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    });

    event.target.value = prefix + formattedWords.join('');
});

window.addEventListener('resize', resizeOverlay);
window.addEventListener('DOMContentLoaded',() => {
    resizeOverlay();
    setupCellClickListeners();
    document.querySelectorAll('.header-inputs input').forEach(input => {
        input.addEventListener('focus', event => event.target.select());
    });
});
</script>
</body>
</html>
