<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Blockage Chart</title>
<link rel="icon" href="https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo1.png" type="image/png">
<style>
:root {
  --primary-color: #005A9C;
  --primary-hover: #004a80;
  --secondary-color: #6c757d;
  --secondary-hover: #5a6268;
  --danger-color: #dc3545;
  --danger-hover: #c82333;
  --success-color: #28a745;
  --success-hover: #218838;
  --bg-color: #f8f9fa;
  --container-bg: #ffffff;
  --text-color: #212529;
  --text-muted: #6c757d;
  --border-color: #dee2e6;
  --card-shadow: 0 4px 12px rgba(0,0,0,0.08);
  --input-focus-shadow: 0 0 0 0.25rem rgba(0, 90, 156, 0.25);
  --input-invalid-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
}

*, *::before, *::after {
  box-sizing: border-box;
}

body {
  font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: var(--bg-color);
  margin: 0;
  padding: 24px;
  min-height: 100vh;
  color: var(--text-color);
  /* text-align: center; -- Removed for new layout */
}

/* body.modal-open { -- Removed, no modal
    overflow: hidden;
} */

.card {
  max-width: 1400px; /* Changed from 950px for 2-col layout */
  margin: auto;
  padding: 24px;
  background: var(--container-bg);
  border-radius: 8px;
  box-shadow: var(--card-shadow);
  border: 1px solid var(--border-color);
  transition: all 0.3s ease;
}

.main-header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--border-color);
    text-align: center; /* Center header content */
}

#pageLogo {
    height: 60px;
    display: block;
}

h1 {
    margin: 0;
    color: var(--primary-color);
    font-size: 24px;
    font-weight: 600;
    letter-spacing: -0.5px;
}

label {
  display: block;
  margin-top: 16px;
  margin-bottom: 8px;
  font-weight: 500;
  color: var(--text-muted);
  font-size: 14px;
  text-align: left;
}

input, select {
  padding: 10px;
  border-radius: 6px;
  border: 1px solid var(--border-color);
  font-size: 15px;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
  background-color: #fff;
  color: var(--text-color);
  width: 100%; /* Make inputs responsive */
  box-sizing: border-box; /* Add box-sizing */
}

input:focus, select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: var(--input-focus-shadow);
}

.header-inputs {
    display: grid; /* Use grid for layout */
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 16px;
    margin-bottom: 0; /* Handled by section */
}

/* Remove old fixed widths */
/* #vesselName { width: 220px; }
#antennaLocation { width: 260px; }
#dateInput { width: 150px; }
#submittedBy { width: 220px; } */

/* --- ADDED RULE --- */
#dateInput {
  width: 85%;
}

/* --- ADDED RULE TO CENTER INPUTS --- */
.header-inputs input {
  justify-self: center; /* Centers the element in its grid cell */
  text-align: center;   /* Centers the text inside the input */
}
/* ----------------------------------- */


#drop-area {
  border: 2px dashed var(--border-color);
  background: #fafcff;
  padding: 20px;
  text-align: center;
  cursor: pointer;
  border-radius: 12px;
  transition: all 0.3s;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 120px;
  margin-bottom: 12px;  
  box-sizing: border-box;
}

#drop-area:hover, #drop-area.highlight {
  border-color: var(--primary-color);
  background: #f0f6ff;
}
#drop-area p {
  font-size: 16px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 0;
}

/* Removed old .content-wrapper */

.button-container {
    display: grid; /* Use grid for layout */
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 0; /* Handled by section */
    margin-top: 25px;
}

.button-container button {
    width: 100%; /* Make buttons responsive */
    max-width: none; /* Remove old max-width */
    margin-top: 0;
}

#grid {
    width: 100%;
    height: auto;
    aspect-ratio: 1 / 1;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    margin: 0;
    background: white;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    position: relative;
    box-sizing: border-box;
}

.cell {
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    display:flex;
    justify-content:center;
    align-items:center;
    overflow:hidden;
    position:relative;
    border-radius:6px;
    cursor:pointer;
    font-size: 2.5rem;
    font-weight: bold;
    color: #ccc;
}
.cell img {
    width:100%;
    height:100%;
    object-fit:cover;
}
.cell:has(img) {
    font-size: 0;
    border: 1px solid #aaa;
}

.center-cell {
    background:white;
    position:relative;
    cursor: default;
    border: none;
}

.center-cell .cell-number {
    display: none;
}

button {
  padding: 10px 16px;
  border: 1px solid transparent;
  border-radius: 6px;
  cursor: pointer;
  font-size: 15px;
  font-weight: 500;
  transition: background-color 0.15s ease-in-out, transform 0.1s ease;
  position: relative;
  -webkit-appearance: none;
}

button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
  transform: none;
  opacity: 0.7;
}

button:active:not(:disabled) {
  transform: scale(0.98);
}

#addBlockBtn, #generatePdf {
    background-color: var(--primary-color);
    color: white;
    border: none;
}
#addBlockBtn:hover:not(:disabled), #generatePdf:hover:not(:disabled) {
  background-color: var(--primary-hover);
}

#removeAllImagesBtn {
    background-color: white;
    color: var(--danger-color);
    border: 1px solid var(--danger-color);
    transition: background-color 0.2s, color 0.2s;
}
#removeAllImagesBtn:hover:not(:disabled) {
    background-color: var(--danger-color);
    color: white;
}
table{width:100%; border-collapse:collapse; margin-top:8px;}
th, td{padding:8px 6px; text-align:center; border-bottom:1px solid var(--border-color);}
th { color: var(--text-muted); font-size: 14px; font-weight: 500; text-align: left;} /* Changed text-align */
#zonesTable th:first-child, #zonesTable th:last-child { text-align: center; } /* Center first/last th */
#zonesTable td button{
  background: var(--danger-color);
  color:white;
  border-radius:4px;
  border:none;
  padding:4px 8px;
  font-weight: bold;
  font-size: 14px;
}
#zonesTable td button:hover {
  background: var(--danger-hover);
}
#zonesTable input {
  width: 100%;
  padding: 6px;
  text-align: center;
  box-sizing: border-box;
}

.zone-color-swatch {
  display: inline-block;
  width: 16px;
  height: 16px;
  border-radius: 4px;
  border: 1px solid rgba(0,0,0,0.1);
  vertical-align: middle;
}
.pdfTable { width:60%; border-collapse:collapse; margin: 0 auto 12px; }
.pdfTable th, .pdfTable td { border:1px solid #aaa; padding:4px; text-align:center; }

#vesselImage {
    position: relative;
    width: 100%;
    height: 100%;
    background-image: url('https://pgarciafer.github.io/satcalc/IMG_0585.PNG');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    filter: drop-shadow(0 4px 12px rgba(0,0,0,0.35));
}
#overlayCanvas { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:2; }


@media screen and (max-width: 600px) {
    body { padding: 10px; }
    .card { padding: 12px; }

    .main-header {
        flex-direction: column;
        gap: 10px;
        margin-bottom: 20px;
        padding-bottom: 20px;
    }
    h1 {
        font-size: 1.5rem; /* 24px */
    }

    .header-inputs {
        /* grid-template-columns: 1fr; -- Already handled by 900px query */
    }
    .header-inputs input {
        width: 100%;
        box-sizing: border-box;
    }
    
    /* Re-apply the 85% width for dateInput even on small screens */
    #dateInput {
        width: 85%;
    }
    
    /* Center header inputs on small screens too */
    .header-inputs input {
      justify-self: center;
      text-align: center;
    }

    /* Remove old fixed-width overrides */
    /* #vesselName, #antennaLocation, #submittedBy { ... } */
    /* #dateInput { ... } */

    #zonesTable td {
        padding: 4px 2px;
    }
    #zonesTable input {
        font-size: 16px;
    }
    
    .button-container {
        /* grid-template-columns: 1fr; -- Already handled by 900px query */
    }
}

/* NEW LAYOUT STYLES */
.app-layout {
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
}
.main-content {
  flex: 3;
  min-width: 400px;
}
.preview-container {
  flex: 2;
  min-width: 300px;
  position: sticky;
  top: 24px;
  align-self: flex-start;
}
#pdf-preview-content {
  border: 1px solid var(--border-color);
  background: #fdfdfd;
  padding: 15px;
  border-radius: 8px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 80vh;
  transform-origin: top center;
}
#pdf-preview-content img {
  width: 100%;
  display: block;
}

.card-section {
    background: #fafcff;
    border: 1px solid #e9eef5;
    border-radius: 8px;
    padding: 16px;
    margin-bottom: 20px;
}
.section-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--primary-color);
    margin-top: 0;
    margin-bottom: 16px;
    text-align: left;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
/* Responsive stacking */
@media screen and (max-width: 900px) {
    .app-layout { flex-direction: column; }
    .preview-container { position: static; }
    .main-content, .preview-container { min-width: 0; }
    .header-inputs { grid-template-columns: 1fr; }
    .button-container { grid-template-columns: 1fr; }
}
/* END NEW LAYOUT STYLES */


#blockagePanel:not(.has-zones) > label,
#blockagePanel:not(.has-zones) #zonesTable thead {
    display: none;
}

.visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Modal styles removed */

/* --- VOICE INPUT STYLES --- */
.input-with-mic {
    position: relative;
    width: 100%;
}

.input-with-mic input {
    padding-right: 40px;
}

.mic-btn {
    position: absolute;
    right: 1px;
    top: 50%;
    transform: translateY(-50%);
    height: calc(100% - 2px);
    width: 38px;
    background: transparent;
    border: none;
    border-left: 1px solid var(--border-color);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0;
    margin: 0;
    color: var(--text-muted);
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mic-btn:hover:not(:disabled) {
    color: var(--primary-color);
    background-color: #f0f6ff;
}

.mic-btn:disabled {
    cursor: not-allowed;
    color: #ccc;
    background-color: transparent;
}

.mic-btn.listening {
    color: var(--danger-color);
    animation: pulseMic 1.5s ease-in-out infinite;
}

@keyframes pulseMic {
    0% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
    }
}
/* --- END VOICE INPUT STYLES --- */
</style>
</head>
<body>
<div class="card">
  <div class="main-header">
    <img src="https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo.png" alt="MTN Logo" id="pageLogo">
    <h1>Blockage Chart</h1>
  </div>

  <div class="app-layout">
    <main class="main-content">
      
      <section class="card-section" id="vessel-info-section">
        <h2 class="section-title">Vessel Information</h2>
        <div class="header-inputs">
          <div class="input-with-mic">
            <input id="vesselName" type="text" placeholder="3LC_VesselName">
            <button class="mic-btn" data-target="vesselName" type="button" aria-label="Use voice input for Vessel Name">🎤</button>
          </div>
          <div class="input-with-mic">
            <input id="antennaLocation" type="text" placeholder="Antenna & Location">
            <button class="mic-btn" data-target="antennaLocation" type="button" aria-label="Use voice input for Antenna & Location">🎤</button>
          </div>
          <input id="dateInput" type="date">
          <div class="input-with-mic">
            <input id="submittedBy" type="text" placeholder="Tech Name">
            <button class="mic-btn" data-target="submittedBy" type="button" aria-label="Use voice input for Tech Name">🎤</button>
          </div>
        </div>
      </section>

      <section class="card-section" id="blockage-zones-section">
        <h2 class="section-title">Blockage Zones</h2>
        <div class="panel" id="blockagePanel">
          <label>Blockage Zones (AZ Start / AZ Stop in degrees)</label>
          <table id="zonesTable">
            <thead><tr><th></th><th>AZ Start</th><th>AZ Stop</th><th>EL</th><th></th></tr></thead>
            <tbody id="zonesBody"></tbody>
          </table>
          <button id="addBlockBtn" style="width: 100%; margin-top: 12px;">Add Blockage Zone</button>
        </div>
      </section>

      <section class="card-section" id="photos-section">
        <h2 class="section-title">Supporting Photos</h2>
        <label for="fileElem" id="drop-area">
          <p>📸 Drop up to 8 photos here or click to browse</p>
        </label>
        <input type="file" id="fileElem" accept="image/*" multiple class="visually-hidden">
        <div id="grid">
          <div class="cell" id="cell-1" data-index="1">8</div>
          <div class="cell" id="cell-2" data-index="2">1</div>
          <div class="cell" id="cell-3" data-index="3">2</div>
          <div class="cell" id="cell-4" data-index="4">7</div>
          <div class="cell center-cell" id="cell-5" data-index="5">
            <div id="vesselImage">
              <canvas id="overlayCanvas"></canvas>
            </div>
          </div>
          <div class="cell" id="cell-6" data-index="6">3</div>
          <div class="cell" id="cell-7" data-index="7">6</div>
          <div class="cell" id="cell-8" data-index="8">5</div>
          <div class="cell" id="cell-9" data-index="9">4</div>
        </div>
      </section>

      <section class="card-section" id="actions-section">
        <h2 class="section-title">Actions</h2>
        <div class="button-container">
            <button id="generatePdf">Generate PDF</button>
            <button id="removeAllImagesBtn">Remove All Images</button>
        </div>
      </section>

    </main>
    
    <aside class="preview-container">
      <h2 class="section-title">Live PDF Preview</h2>
      <div id="pdf-preview-content">
        </div>
    </aside>
  </div> <input type="file" id="singleFileElem" accept="image/*" class="visually-hidden">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// Set default date to today
const today = new Date();
const yyyy = today.getFullYear();
const mm = String(today.getMonth()+1).padStart(2,'0');
const dd = String(today.getDate()).padStart(2,'0');
document.getElementById('dateInput').value = `${yyyy}-${mm}-${dd}`;

// --------- Blockage Zones -----------
const ZONE_COLORS = ['#E53935','#1E88E5','#43A047','#FB8C00','#8E24AA','#D81B60','#00ACC1','#FDD835'];
const zonesBody=document.getElementById('zonesBody');
const overlayCanvas=document.getElementById('overlayCanvas');
const overlayCtx=overlayCanvas.getContext('2d');
const vesselImg=document.getElementById('vesselImage');

function hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function validateZoneRow(tr) {
    const startInput = tr.cells[1].querySelector('input');
    const stopInput = tr.cells[2].querySelector('input');
    const start = parseFloat(startInput.value);
    const stop = parseFloat(stopInput.value);

    if (isNaN(start) || isNaN(stop)) {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
        return;
    }

    let angle = stop - start;
    if (angle < 0) {
        angle += 360; // Assumes wrap-around
    }

    if (angle > 180) {
        startInput.style.borderColor = 'red';
        stopInput.style.borderColor = 'red';
    } else {
        startInput.style.borderColor = '';
        stopInput.style.borderColor = '';
    }
}

function formatNumber(num){return(Math.round(num*100)/100).toString().replace(/\.00$/,'');}

function resizeOverlay() {
    const rect = vesselImg.getBoundingClientRect();
    const size = Math.min(rect.width, rect.height);
    overlayCanvas.width = size;
    overlayCanvas.height = size;
    overlayCanvas.style.width = size + 'px';
    overlayCanvas.style.height = size + 'px';
    overlayCanvas.style.left = ((rect.width - size) / 2) + 'px';
    overlayCanvas.style.top = ((rect.height - size) / 2) + 'px';
    overlayCtx.setTransform(1, 0, 0, 1, 0, 0);
    drawZones();
}


function drawZones() {
    const blockagePanel = document.getElementById('blockagePanel');
    const rows = zonesBody.querySelectorAll('tr');
    
    blockagePanel.classList.toggle('has-zones', rows.length > 0);

    const ctx = overlayCtx;
    const size = overlayCanvas.width;
    const cx = size / 2;
    const cy = size / 2;
    const R = size * 0.42;

    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

    rows.forEach(row => {
        const color = row.dataset.color || '#ff0000';
        const start = parseFloat(row.cells[1].querySelector('input').value) || 0;
        const stop = parseFloat(row.cells[2].querySelector('input').value) || 0;
        const el = Math.min(Math.max(parseFloat(row.cells[3].querySelector('input').value) || 0, 0), 90);
        const opacity = 0.2 + (el / 90) * 0.6;

        const startRad = (start - 90) * Math.PI / 180;
        const stopRad = (stop - 90) * Math.PI / 180;

        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, R, startRad, stopRad, false);
        ctx.closePath();
        ctx.fillStyle = hexToRgba(color, opacity);
        ctx.fill();
        ctx.restore();

        let midAngle = stop < start ?
            ((start - 90) * Math.PI / 180 + (stop + 360 - 90) * Math.PI / 180) / 2 :
            (startRad + stopRad) / 2;

        const labelX = cx + Math.cos(midAngle) * R * 0.7;
        const labelY = cy + Math.sin(midAngle) * R * 0.7;
        ctx.fillStyle = 'black';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${Math.round(el)}°`, labelX, labelY);
    });
}


document.getElementById('antennaLocation').addEventListener('input', (event) => {
event.target.value = event.target.value.toUpperCase();
});

document.getElementById('submittedBy').addEventListener('change', (event) => {
let value = event.target.value.trim();
let words = value.split(/\s+/);
let formattedWords = words.map(word => {
    if (word.length === 0) return '';
    return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
});
event.target.value = formattedWords.join(' ');
});

function createZoneRow(start = 0, stop = 0, el = 0) {
    const tr = document.createElement('tr');
    const zoneIndex = zonesBody.children.length;
    const color = ZONE_COLORS[zoneIndex % ZONE_COLORS.length];
    tr.dataset.color = color;
    
    tr.innerHTML = `
    <td><span class="zone-color-swatch" style="background-color: ${color};" title="Zone Color"></span></td>
    <td><input inputmode="decimal" value="${formatNumber(start)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(stop)}"></td>
    <td><input inputmode="decimal" value="${formatNumber(el)}"></td>
    <td><button>X</button></td>
    `;
    
    const inputs = tr.querySelectorAll('input');
    inputs.forEach(input => input.addEventListener('focus', event => event.target.select()));

    const startInput = inputs[0];
    const stopInput = inputs[1];
    const elInput = inputs[2];

    const azHandler = () => {
        validateZoneRow(tr);
        drawZones();
        updatePdfPreview(); // Update preview
    };

    startInput.addEventListener('input', azHandler);
    stopInput.addEventListener('input', azHandler);

    startInput.addEventListener('blur', () => {
        startInput.value = formatNumber(Math.min(Math.max(parseFloat(startInput.value) || 0, 0), 360));
        azHandler();
    });
    stopInput.addEventListener('blur', () => {
        stopInput.value = formatNumber(Math.min(Math.max(parseFloat(stopInput.value) || 0, 0), 360));
        azHandler();
    });

    elInput.addEventListener('input', () => {
        drawZones();
        updatePdfPreview(); // Update preview
    });
    elInput.addEventListener('blur', () => {
        elInput.value = formatNumber(Math.min(Math.max(parseFloat(elInput.value) || 0, 0), 90));
        drawZones();
        updatePdfPreview(); // Update preview
    });

    tr.querySelector('button').addEventListener('click', () => {
        tr.remove();
        drawZones();
        updatePdfPreview(); // Update preview
    });

    zonesBody.appendChild(tr);
    drawZones();
    validateZoneRow(tr);
    updatePdfPreview(); // Update preview
}


document.getElementById('addBlockBtn').addEventListener('click',()=>createZoneRow());

// --------- Drag & Drop 8 Photos -----------
const dropArea=document.getElementById('drop-area');
const fileInput=document.getElementById('fileElem');
["dragenter","dragover","dragleave","drop"].forEach(e=>{
dropArea.addEventListener(e,ev=>{ev.preventDefault();ev.stopPropagation();});
});
["dragenter","dragover"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.add("highlight")));
["dragleave","drop"].forEach(e=>dropArea.addEventListener(e,()=>dropArea.classList.remove("highlight")));
dropArea.addEventListener("drop",e=>handleFiles(e.dataTransfer.files));
fileInput.addEventListener("change",()=>handleFiles(fileInput.files));

const placementOrder=[2,3,6,9,8,7,4,1];

function processImage(file, index) {
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxSize = 600;
            let { width, height } = img;

            if (width > height) {
                if (width > maxSize) { height *= maxSize / width; width = maxSize; }
            } else {
                if (height > maxSize) { width *= maxSize / height; height = maxSize; }
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
            
            const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.7);
            const cell = document.getElementById(`cell-${index}`);
            if (cell) {
                cell.innerHTML = "";
                const imgEl = document.createElement('img');
                imgEl.src = compressedDataUrl;
                cell.appendChild(imgEl);
                updatePdfPreview(); // Update preview
            }
        };
        img.onerror = () => {
            console.error("Error loading image from data URL.");
            alert("Could not load image. Please try a different photo.");
        };
        img.src = e.target.result;
    };
    reader.onerror = function() {
        console.error("FileReader failed to read the file.");
        alert("Failed to read the selected file. Please try again.");
    };
    reader.readAsDataURL(file);
}


function handleFiles(files){Array.from(files).slice(0,8).forEach((file,i)=>processImage(file,placementOrder[i]));}


// --------- One-by-one photo selection -----------
const singleFileElem = document.getElementById('singleFileElem');
let currentCellIndex = null;

function openFilePickerForCell(index) {
    currentCellIndex = index;
    singleFileElem.click();
}

singleFileElem.addEventListener('change', () => {
    if (singleFileElem.files.length > 0 && currentCellIndex) {
        processImage(singleFileElem.files[0], currentCellIndex);
    }
    singleFileElem.value = '';
});

function setupCellClickListeners() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const index = cell.dataset.index;
        const initialNumber = cell.innerHTML.trim();  
        
        cell.removeEventListener('click', handleCellClick);  
        cell.addEventListener('click', handleCellClick);

        function handleCellClick() {
            if (cell.querySelector('img')) {
                if (window.confirm("Replace existing picture? Or click 'Cancel' to remove it.")) {
                    openFilePickerForCell(index);
                } else {
                    cell.innerHTML = initialNumber;
                    updatePdfPreview(); // Update preview
                }
            } else {
                openFilePickerForCell(index);
            }
        }
    });
}
// -------------------------------------------------------------

// --------- Remove All Images Function -----------
function removeAllImages() {
    const cells = document.querySelectorAll('.cell:not(.center-cell)');
    cells.forEach(cell => {
        const cellMap = {"1": "8", "2": "1", "3": "2", "4": "7", "6": "3", "7": "6", "8": "5", "9": "4"};
        cell.innerHTML = cellMap[cell.dataset.index] || '';
    });
    updatePdfPreview(); // Update preview
}

document.getElementById('removeAllImagesBtn').addEventListener('click', removeAllImages);
// ------------------------------------------------

// --------- PDF Generation & Preview (MERGED) -----------
// Modal variables removed
let generatedCanvas = null;
let previewTimeout;

// Modal functions (openModal, closeModal) removed

// NEW Live Preview Function
async function updatePdfPreview() {
    clearTimeout(previewTimeout);
    const previewContainer = document.getElementById('pdf-preview-content');
    
    // Show a simple text loader only if there's no image
    if (!previewContainer.querySelector('img')) {
        previewContainer.innerHTML = 'Updating...';
    }
    
    previewTimeout = setTimeout(async () => {
        try {
            generatedCanvas = await generatePdfContentCanvas(); // Use original hi-fi function
            
            let previewImg = previewContainer.querySelector('img');
            if (!previewImg) {
                previewContainer.innerHTML = ''; // Clear 'Updating...'
                previewImg = document.createElement('img');
                previewContainer.appendChild(previewImg);
            }
            
            previewImg.src = generatedCanvas.toDataURL('image/jpeg', 0.9);

        } catch (err) {
            console.error("Live preview failed:", err);
            previewContainer.innerHTML = '<p style="color:red;">Preview failed to load.</p>';
        }
    }, 300); // 300ms debounce
}

// Original (high-fidelity) PDF content generator
async function generatePdfContentCanvas() {
    const pdfContainer = document.createElement('div');
    pdfContainer.style.width = '720px';
    pdfContainer.style.background = '#fff';
    pdfContainer.style.padding = '10px';
    pdfContainer.style.borderRadius = '8px';
    // Position off-screen
    pdfContainer.style.position = 'absolute';
    pdfContainer.style.left = '-9999px';
    pdfContainer.style.top = '0';


    const vesselNameVal = document.getElementById('vesselName').value.trim();
    const antennaLocVal = document.getElementById('antennaLocation').value.trim();
    const dateVal = document.getElementById('dateInput').value;
    const submittedByVal = document.getElementById('submittedBy').value.trim();

    if (vesselNameVal || antennaLocVal || dateVal || submittedByVal) {
        const infoDiv = document.createElement('div');
        infoDiv.style.cssText = 'display:flex; align-items:center; justify-content:center; margin-bottom:12px;';
        const logoImg = document.createElement('img');
        logoImg.src = 'https://raw.githubusercontent.com/pgarciafer/MTNblockagechart/main/logo.png';
        logoImg.style.cssText = 'height:50px; margin-right:12px;';
        infoDiv.appendChild(logoImg);
        const textDiv = document.createElement('div');
        textDiv.style.textAlign = 'left';
        if(vesselNameVal) textDiv.innerHTML += `<div><strong>Vessel:</strong> ${vesselNameVal}</div>`;
        if(antennaLocVal) textDiv.innerHTML += `<div><strong>Antenna & Location:</strong> ${antennaLocVal}</div>`;
        if(dateVal) textDiv.innerHTML += `<div><strong>Date:</strong> ${dateVal}</div>`;
        if(submittedByVal) textDiv.innerHTML += `<div><strong>Submitted by:</strong> ${submittedByVal}</div>`;
        infoDiv.appendChild(textDiv);
        pdfContainer.appendChild(infoDiv);
    }
    
    const zonesData = Array.from(zonesBody.querySelectorAll('tr')).map(row => ({
        start: parseFloat(row.cells[1].querySelector('input').value) || 0,
        stop: parseFloat(row.cells[2].querySelector('input').value) || 0,
        el: parseFloat(row.cells[3].querySelector('input').value) || 0,
        color: row.dataset.color || '#ff0000'
    }));

    if (zonesData.length > 0) {
        const gridCanvas = createBlockageGridCanvas(zonesData);
        const gridImg = document.createElement('img');
        gridImg.src = gridCanvas.toDataURL('image/png');
        gridImg.style.cssText = 'display:block; margin:10px auto;';
        pdfContainer.appendChild(gridImg);
    }

    function createBlockageGridCanvas(zones) {
        const cols = 72; const rows = 18; const cellSize = 9; const margin = 20;
        const width = cols * cellSize + margin * 2; const height = rows * cellSize + margin * 2;
        const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0, 0, width, height);
        ctx.translate(margin, height - margin);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -rows * cellSize); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(cols * cellSize, 0); ctx.stroke();
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 0.5;
        for (let c = 1; c < cols; c++) { const x = c * cellSize; ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, -rows * cellSize); ctx.stroke(); }
        for (let r = 1; r < rows; r++) { const y = -r * cellSize; ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cols * cellSize, y); ctx.stroke(); }
        
        zones.forEach(zone => {
            ctx.fillStyle = hexToRgba(zone.color, 0.7);
            const elClamped = Math.min(Math.max(zone.el, 0), 90);
            const rowTop = Math.floor((elClamped / 90) * rows);
            const normalizeAz = az => (az < 180 ? 36 + Math.floor(az / 5) : Math.floor((az - 180) / 5));
            const cStart = normalizeAz(zone.start); const cStop = normalizeAz(zone.stop);
            const fillCell = (c, r) => ctx.fillRect(c * cellSize, -r * cellSize - cellSize, cellSize, cellSize);
            if (cStart <= cStop) { for (let c = cStart; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); }  
            else { for (let c = cStart; c < cols; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); for (let c = 0; c <= cStop; c++) for (let r = 0; r <= rowTop; r++) fillCell(c, r); }
        });

        ctx.fillStyle = '#000'; ctx.font = '8px sans-serif'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let az = 180; az <= 540; az += 10) {
            let colIndex = az <= 360 ? (az - 180) / 5 : (az - 540) / 5 + 72;
            const x = colIndex * cellSize; if (x < 0 || x > cols * cellSize) continue;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, 3); ctx.stroke();
            ctx.save(); ctx.translate(x, 6); ctx.rotate(-Math.PI / 4); ctx.fillText((az % 360).toString(), 0, 0); ctx.restore();
        }
        ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        for (let el = 0; el <= 90; el += 5) { const y = -(el / 90) * rows * cellSize; ctx.beginPath(); ctx.moveTo(-3, y); ctx.lineTo(0, y); ctx.stroke(); ctx.fillText(el.toString(), -8, y); }
        return canvas;
    }

    async function createVesselCanvasForPDF(zones) {
        const img = new Image(); img.crossOrigin = "anonymous"; img.src = 'https://pgarciafer.github.io/satcalc/IMG_0585.PNG';
        await new Promise(resolve => img.onload = resolve);
        const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
        const size = Math.min(img.naturalWidth, img.naturalHeight); const cx = img.naturalWidth / 2; const cy = img.naturalHeight / 2; const R = size * 0.42;
        zones.forEach(zone => {
            if (isNaN(zone.start) || isNaN(zone.stop)) return;
            const startRad = (zone.start - 90) * Math.PI / 180; const stopRad = (zone.stop - 90) * Math.PI / 180;
            const elClamped = Math.min(Math.max(zone.el, 0), 90); const opacity = 0.2 + (elClamped / 90) * 0.6;
            ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 8;
            ctx.beginPath(); ctx.moveTo(cx, cy); ctx.arc(cx, cy, R, startRad, stopRad, false); ctx.closePath(); ctx.fillStyle = hexToRgba(zone.color, opacity); ctx.fill();
            ctx.restore();
            let midAngle = (zone.stop < zone.start) ? ((zone.start - 90) * Math.PI / 180 + (zone.stop + 360 - 90) * Math.PI / 180) / 2 : (startRad + stopRad) / 2;
            const labelX = cx + Math.cos(midAngle) * R * 0.7; const labelY = cy + Math.sin(midAngle) * R * 0.7;
            ctx.fillStyle = 'black'; ctx.font = '28px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${Math.round(zone.el)}°`, labelX, labelY);
        });
        return canvas;
    }

    const gridClone = document.getElementById('grid').cloneNode(true);
    const centerCellClone = gridClone.querySelector('#cell-5');
    centerCellClone.innerHTML = '';
    const vesselCanvas = await createVesselCanvasForPDF(zonesData);
    const imgEl = document.createElement('img');
    imgEl.src = vesselCanvas.toDataURL('image/png');
    centerCellClone.appendChild(imgEl);

    pdfContainer.appendChild(gridClone);
    document.body.appendChild(pdfContainer);
    
    const canvas = await html2canvas(pdfContainer, { scale: 2, useCORS: true });
    
    pdfContainer.remove();
    return canvas;
}

// --- THIS FUNCTION IS UPDATED ---
async function downloadPdf() {
    if (!generatedCanvas) {
        alert("Preview data not found. Please generate the preview again.");
        return;
    }

    try {
        const vesselNameVal = document.getElementById('vesselName').value.trim();
        const antennaLocVal = document.getElementById('antennaLocation').value.trim();
        const dateVal = document.getElementById('dateInput').value;
        const cleanDate = dateVal.replace(/-/g, '');
        const fileName = `${vesselNameVal}_BlockageChart_${antennaLocVal}_${cleanDate}.pdf`.replace(/[\/\\?%*:|"<>]/g, '_');

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF('p', 'mm', 'a4');
        const imgData = generatedCanvas.toDataURL('image/jpeg', 0.95);
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = pdf.internal.pageSize.getHeight();
        const ratio = imgProps.width / imgProps.height;
        let imgWidth = pdfWidth;
        let imgHeight = imgWidth / ratio;
        let posY = (pdfHeight - imgHeight > 0) ? (pdfHeight - imgHeight) / 2 : 0;

        // On very tall (unlikely) images, fit to height instead
        if (imgHeight > pdfHeight) {
            imgHeight = pdfHeight;
            imgWidth = imgHeight * ratio;
            posY = 0;
        }

        pdf.addImage(imgData, 'JPEG', 0, posY, imgWidth, imgHeight);

        // --- NEW LOGIC ---
        // Check if Web Share API is available (common on modern mobile browsers)
        if (navigator.share && navigator.canShare) {
            // 1. Get the PDF as a blob
            const pdfBlob = pdf.output('blob');
            
            // 2. Create a File object from the blob
            const pdfFile = new File([pdfBlob], fileName, { type: 'application/pdf' });

            // 3. Use navigator.share to share the file
            await navigator.share({
                title: 'Blockage Chart',
                text: `Blockage chart for ${vesselNameVal}`,
                files: [pdfFile]
            });
            // Successfully shared, no download needed.
            return; 

        } else {
            // --- FALLBACK LOGIC ---
            // Web Share API not available (e.g., desktop browser), use the original download method.
            pdf.save(fileName);
        }
        
    } catch (err) {
        if (err.name === 'AbortError') {
            // This happens if the user cancels the share sheet.
            // It's not a real error, so we can safely ignore it.
            console.log("Share cancelled by user.");
        } else {
            console.error("PDF generation/share failed:", err);
            alert("PDF generation or sharing failed. Please check the console for details.");
        }
    }
}
// --- END OF UPDATED FUNCTION ---


// Replaced modal button listeners with direct download
document.getElementById('generatePdf').addEventListener('click', downloadPdf);
// downloadPdfBtn.addEventListener('click', downloadPdf); // Removed

// Add live preview listeners for header inputs
document.getElementById('vesselName').addEventListener('input', updatePdfPreview);
document.getElementById('antennaLocation').addEventListener('input', updatePdfPreview);
document.getElementById('dateInput').addEventListener('input', updatePdfPreview);
document.getElementById('submittedBy').addEventListener('input', updatePdfPreview);


document.getElementById('vesselName').addEventListener('change', (event) => {
    let value = event.target.value.trim();
    const prefixRegex = /^[A-Z]{3}_/;
    let prefix = '';
    let namePart = value;

    if (prefixRegex.test(value)) {
        prefix = value.substring(0, 4);
        namePart = value.substring(4);
    } else if (value.length >= 3) {
        prefix = value.substring(0, 3).toUpperCase() + '_';
        namePart = value.substring(3);
    }

    let words = namePart.split(/\s+/);
    let formattedWords = words.map(word => {
        if (word.length === 0) return '';
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    });

    event.target.value = prefix + formattedWords.join('');
});

window.addEventListener('resize', resizeOverlay);
window.addEventListener('DOMContentLoaded',() => {
    resizeOverlay();
    setupCellClickListeners();
    document.querySelectorAll('.header-inputs input').forEach(input => {
        input.addEventListener('focus', event => event.target.select());
    });
    
    // --------- VOICE INPUT SCRIPT -----------
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    let activeMicButton = null;
    const originalPlaceholders = {};

    function startListening(event) {
        if (activeMicButton) {
            recognition.stop();
            return;
        }
        const btn = event.currentTarget;
        const targetId = btn.dataset.target;
        const targetInput = document.getElementById(targetId);
        if (!targetInput) return;
        
        activeMicButton = btn;
        
        document.querySelectorAll('.mic-btn').forEach(b => b.disabled = true);
        btn.disabled = false;
        btn.classList.add('listening');
        targetInput.placeholder = 'Listening...';

        recognition.start();
    }

    function handleRecognitionResult(event) {
        const transcript = event.results[0][0].transcript;
        const targetId = activeMicButton.dataset.target;
        const targetInput = document.getElementById(targetId);
        
        if (targetInput) {
            targetInput.value = transcript;
            targetInput.dispatchEvent(new Event('change', { bubbles: true }));
            targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
    }

    function handleRecognitionError(event) {
        console.error('Speech recognition error', event.error);
        let errorMessage = `An unknown speech recognition error occurred: ${event.error}`;
        
        switch (event.error) {
            case 'audio-capture':
                errorMessage = "Could not start voice input. Please ensure your microphone is connected and that you've allowed this site to access it. You might need to check your browser's permission settings in the address bar.";
                break;
            case 'not-allowed':
                errorMessage = "Voice input is disabled. You need to grant microphone permissions for this site. Please click the microphone icon in your address bar and allow access.";
                break;
            case 'no-speech':
                errorMessage = "No speech was detected. Please try speaking again.";
                break;
            case 'network':
                errorMessage = "A network error occurred during speech recognition. Please check your internet connection.";
                break;
            case 'service-not-allowed':
                 errorMessage = "Voice input service is not allowed. This might be due to your browser or system settings.";
                 break;
        }
        
        alert(errorMessage);
    }

    function handleRecognitionEnd() {
        if (!activeMicButton) return;
        const targetId = activeMicButton.dataset.target;
        const targetInput = document.getElementById(targetId);
        
        activeMicButton.classList.remove('listening');
        document.querySelectorAll('.mic-btn').forEach(b => b.disabled = false);
        
        if (targetInput) {
            targetInput.placeholder = originalPlaceholders[targetId] || '';
        }
        activeMicButton = null;
    }

    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onresult = handleRecognitionResult;
        recognition.onerror = handleRecognitionError;
        recognition.onend = handleRecognitionEnd;

        document.querySelectorAll('.mic-btn').forEach(btn => {
            const targetId = btn.dataset.target;
            const targetInput = document.getElementById(targetId);
            if (targetInput) {
                originalPlaceholders[targetId] = targetInput.placeholder;
            }
            btn.addEventListener('click', startListening);
        });
    } else {
        console.warn('Speech Recognition API not supported in this browser.');
        document.querySelectorAll('.mic-btn').forEach(btn => btn.style.display = 'none');
    }
    // --------- END VOICE INPUT SCRIPT -----------

    updatePdfPreview(); // Load initial preview
});
</script>
</body>
</html>
